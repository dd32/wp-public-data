{
    "name": "WP Router",
    "slug": "wp-router",
    "version": "0.5",
    "author": "<a href=\"http://flightless.us/\">Flightless</a>",
    "author_profile": "https://profiles.wordpress.org/jbrinley/",
    "contributors": {
        "jbrinley": {
            "profile": "https://profiles.wordpress.org/jbrinley/",
            "avatar": "https://secure.gravatar.com/avatar/8398939a88a8ac7bb49e36a4ed0001f5?s=96&d=monsterid&r=g",
            "display_name": "Jonathan Brinley"
        }
    },
    "requires": "3.0",
    "tested": "3.4.2",
    "requires_php": false,
    "requires_plugins": [],
    "compatibility": [],
    "rating": 74,
    "ratings": {
        "5": 2,
        "4": 0,
        "3": 0,
        "2": 0,
        "1": 1
    },
    "num_ratings": 3,
    "support_url": "https://wordpress.org/support/plugin/wp-router/",
    "support_threads": 0,
    "support_threads_resolved": 0,
    "active_installs": 1000,
    "downloaded": 13663,
    "last_updated": "2012-08-06 3:06pm GMT",
    "added": "2011-05-23",
    "homepage": "https://github.com/jbrinley/WP-Router",
    "sections": {
        "description": "<p>WordPress&#8217;s rewrite rules and query variables provide a powerful system<br />\nfor mapping URL strings to collections of posts. Every request is parsed<br />\ninto query variables and turned into a SQL query via <code>$wp_query-&gt;query()</code>.</p>\n<p>Sometimes, though, you don&#8217;t want to display a list of posts. You just want<br />\na URL to map to a callback function, with the output displayed in place of<br />\nposts in whatever theme you happen to be using.</p>\n<p>That&#8217;s where WP Router comes in. It handles all the messy bits of registering<br />\npost types, query variables, rewrite rules, etc., and lets you write code to<br />\ndo what you want it to do. One function call is all it takes to map a<br />\nURL to your designated callback function and display the return value in the page.</p>\n<p>Created by <a href=\"http://flightless.us\" rel=\"nofollow ugc\">Flightless</a></p>\n<h3>Usage</h3>\n<h4>Creating Routes</h4>\n<ul>\n<li>Your plugin should hook into the <code>wp_router_generate_routes</code> action.<br />\nThe callback should take one argument, a <code>WP_Router</code> object.</li>\n<li>\n<p>Register a route and its callback using <code>WP_Router::add_route( $id, $args )</code></p>\n<ul>\n<li><code>$id</code> is a unique string your plugin should use to identify the route</li>\n<li>\n<p><code>$args</code> is an associative array, that sets the following properties for your route.<br />\nAny omitted argument will use the default value.</p>\n<ul>\n<li>\n<p><code>path</code> (required) &#8211; A regular expression to match against the request path.<br />\nThis corresponds to the array key you would use when creating rewrite rules for WordPress.</p>\n</li>\n<li>\n<p><code>query_vars</code> &#8211; An associative array, with the keys being query vars, and the<br />\nvalues being explicit strings or integers corresponding to matches in the path regexp.<br />\n Any query variables included here will be automatically registered.</p>\n</li>\n<li>\n<p><code>title</code> &#8211; The title of the page.</p>\n</li>\n<li>\n<p><code>title_callback</code> &#8211; A callback to use for dynamically generating the title.<br />\nDefaults to <code>__()</code>. If <code>NULL</code>, the <code>title</code> argument will be used as-is. if<br />\n    page_callback or <code>access_callback</code> returns <code>FALSE</code>, <code>title_callback</code> will not be called.</p>\n<pre><code>title_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>title_arguments</code> &#8211; An array of query variables whose values will be passed<br />\nas arguments to <code>title_callback</code>. Defaults to the value of <code>title</code>. If an argument<br />\nis not a registered query variable, it will be passed as-is.</p>\n</li>\n<li>\n<p><code>page_callback</code> (required) &#8211; A callback to use for dynamically generating the<br />\ncontents of the page. The callback should either echo or return the contents of<br />\nthe page (if both, the returned value will be appended to the echoed value). If<br />\n    FALSE is returned, nothing will be output, and control of the page contents will<br />\nbe handed back to WordPress. The callback will be called during the <code>parse_request</code><br />\nphase of WordPress&#8217;s page load. If <code>access_callback</code> returns <code>FALSE</code>, <code>page_callback</code><br />\nwill not be called.</p>\n<pre><code>page_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>page_arguments</code> &#8211; An array of query variables whose values will be passed as<br />\narguments to <code>page_callback</code>. If an argument is not a registered query variable,<br />\nit will be passed as-is.</p>\n</li>\n<li>\n<p><code>access_callback</code> &#8211; A callback to determine if the user has permission to access<br />\nthis page. If <code>access_arguments</code> is provided, default is <code>current_user_can</code>, otherwise<br />\ndefault is <code>TRUE</code>. If the callback returns <code>FALSE</code>, anonymous users are redirected to<br />\nthe login page, authenticated users get a 403 error.</p>\n<pre><code>access_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>access_arguments</code> &#8211; An array of query variables whose values will be passed<br />\nas arguments to <code>access_callback</code>. If an argument is not a registered query variable,<br />\nit will be passed as-is.</p>\n</li>\n<li>\n<p><code>template</code> &#8211; An array of templates that can be used to display the page. If a path<br />\nis absolute, it will be used as-is; relative paths allow for overrides by the theme.<br />\nThe string <code>$id</code> will be replaced with the ID of the route. If no template is found,<br />\nfallback templates are (in this order): <code>route-$id.php</code>, <code>route.php</code>, <code>page-$id.php</code>,<br />\n    page.php, <code>index.php</code>. If FALSE is given instead of an array, the page contents will<br />\nbe printed before calling <code>exit()</code> (you can also accomplish this by printing your output<br />\nand exiting directly from your callback function).</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Example:<br />\n    $router-&gt;add_route(&#8216;wp-router-sample&#8217;, array(<br />\n        &#8216;path&#8217; =&gt; &#8216;^wp_router/(.*?)$&#8217;,<br />\n        &#8216;query_vars&#8217; =&gt; array(<br />\n            &#8216;sample_argument&#8217; =&gt; 1,<br />\n        ),<br />\n        &#8216;page_callback&#8217; =&gt; array(get_class(), &#8216;sample_callback&#8217;),<br />\n        &#8216;page_arguments&#8217; =&gt; array(&#8216;sample_argument&#8217;),<br />\n        &#8216;access_callback&#8217; =&gt; TRUE,<br />\n        &#8216;title&#8217; =&gt; &#8216;WP Router Sample Page&#8217;,<br />\n        &#8216;template&#8217; =&gt; array(&#8216;sample-page.php&#8217;, dirname(<strong>FILE</strong>).DIRECTORY_SEPARATOR.&#8217;sample-page.php&#8217;)<br />\n    ));</p>\n<p>In this example, the path <code>http://example.com/wp_router/my_sample_path/</code> will call<br />\nthe function <code>sample_callback</code> in the calling class. The value of the <code>sample_argument</code><br />\nquery variable, in this case &#8220;my_sample_path&#8221;, will be provided as the first and only<br />\nargument to the callback function. If the file <code>sample-page.php</code> is found in the theme,<br />\nit will be used as the template, otherwise <code>sample-page.php</code> in your plugin directory will<br />\nbe used (if that&#8217;s not found either, fall back to <code>route-wp-router-sample.php</code>, etc.).</p>\n<h4>Editing Routes</h4>\n<ul>\n<li>You can hook into the <code>wp_router_alter_routes</code> action to modify routes created by other plugins. The callback should take one argument, a <code>WP_Router</code> object.</li>\n</ul>\n<h4>Public API Functions</h4>\n<p>Creating or changing routes should always occur in the context of the <code>wp_router_generate_routes</code> or <code>wp_router_alter_routes</code> actions, using the <code>WP_Router</code> object supplied to your callback function.</p>\n<ul>\n<li><code>WP_Router::edit_route( string $id, array $changes )</code> &#8211; update each<br />\nproperty given in <code>$changes</code> for the route with the given ID. Any properties<br />\nnot given in <code>$changes</code> will be left unaltered.</li>\n<li><code>WP_Router::remove_route( string $id )</code> &#8211; delete the route with the given ID</li>\n<li><code>WP_Router::get_route( string $id )</code> &#8211; get the <code>WP_Route</code> object for the given ID</li>\n<li><code>WP_Router::get_url( string $id, array $arguments )</code> &#8211; get the URL to reach the route with the given ID, with the given query variables and their values</li>\n<li><code>WP_Route::get( string $property )</code> &#8211; get the value of the specified property for<br />\nthe <code>WP_Route</code> instance</li>\n</ul>\n",
        "installation": "<ol>\n<li>Download and unzip the plugin</li>\n<li>Upload the <code>WP-Router</code> folder to the <code>/wp-content/plugins/</code> directory</li>\n<li>Activate the plugin through the &#8216;Plugins&#8217; menu in WordPress</li>\n<li>You should see the sample page at http://example.org/wp_router/sample/. Apart from that, there is no public UI for this plugin. You will not see any changes unless the plugin&#8217;s API is called by another active plugin.</li>\n</ol>\n",
        "changelog": "<h4>0.5</h4>\n<ul>\n<li>Filter get_permalink on router pages to point to the requested URI</li>\n<li>Filter post meta for the placeholder page when on a router page to provide a title to WP SEO</li>\n<li>Added <code>wp_router_placeholder_postmeta</code> filter for adding additional meta to the placeholder page</li>\n</ul>\n<h4>0.4</h4>\n<ul>\n<li>Prevent redirect from route pages with the &#8220;page&#8221; or &#8220;paged&#8221; query arg</li>\n</ul>\n<h4>0.3.3</h4>\n<ul>\n<li>Prevent redirect from all route pages when %category% is in the permastruct</li>\n<li>Redirect placeholder page to the blog front page</li>\n<li>Fix usage of translation functions</li>\n</ul>\n<h4>0.3.2</h4>\n<ul>\n<li>Make $arguments param optional for WP_Router::get_url() and WP_Router::url()</li>\n</ul>\n<h4>0.3.1</h4>\n<ul>\n<li>Added WP_Router::get_url()</li>\n<li>Added WP_Route::url()</li>\n</ul>\n<h4>0.3</h4>\n<ul>\n<li>Added <code>FALSE</code> option to template parameter to indicate immediate <code>exit()</code></li>\n<li>Added option to specify different callback functions depending on the HTTP request method</li>\n<li>Verified compatibility with WordPress 3.0</li>\n<li>Added WP_Router::get_url() function</li>\n</ul>\n<h4>0.2</h4>\n<ul>\n<li>Added the <code>template</code> argument</li>\n</ul>\n<h4>0.1</h4>\n<ul>\n<li>Initial version</li>\n</ul>\n"
    },
    "short_description": "Provides a simple API for mapping requests to callback functions.",
    "description": "<p>WordPress&#8217;s rewrite rules and query variables provide a powerful system<br />\nfor mapping URL strings to collections of posts. Every request is parsed<br />\ninto query variables and turned into a SQL query via <code>$wp_query-&gt;query()</code>.</p>\n<p>Sometimes, though, you don&#8217;t want to display a list of posts. You just want<br />\na URL to map to a callback function, with the output displayed in place of<br />\nposts in whatever theme you happen to be using.</p>\n<p>That&#8217;s where WP Router comes in. It handles all the messy bits of registering<br />\npost types, query variables, rewrite rules, etc., and lets you write code to<br />\ndo what you want it to do. One function call is all it takes to map a<br />\nURL to your designated callback function and display the return value in the page.</p>\n<p>Created by <a href=\"http://flightless.us\" rel=\"nofollow ugc\">Flightless</a></p>\n<h3>Usage</h3>\n<h4>Creating Routes</h4>\n<ul>\n<li>Your plugin should hook into the <code>wp_router_generate_routes</code> action.<br />\nThe callback should take one argument, a <code>WP_Router</code> object.</li>\n<li>\n<p>Register a route and its callback using <code>WP_Router::add_route( $id, $args )</code></p>\n<ul>\n<li><code>$id</code> is a unique string your plugin should use to identify the route</li>\n<li>\n<p><code>$args</code> is an associative array, that sets the following properties for your route.<br />\nAny omitted argument will use the default value.</p>\n<ul>\n<li>\n<p><code>path</code> (required) &#8211; A regular expression to match against the request path.<br />\nThis corresponds to the array key you would use when creating rewrite rules for WordPress.</p>\n</li>\n<li>\n<p><code>query_vars</code> &#8211; An associative array, with the keys being query vars, and the<br />\nvalues being explicit strings or integers corresponding to matches in the path regexp.<br />\n Any query variables included here will be automatically registered.</p>\n</li>\n<li>\n<p><code>title</code> &#8211; The title of the page.</p>\n</li>\n<li>\n<p><code>title_callback</code> &#8211; A callback to use for dynamically generating the title.<br />\nDefaults to <code>__()</code>. If <code>NULL</code>, the <code>title</code> argument will be used as-is. if<br />\n    page_callback or <code>access_callback</code> returns <code>FALSE</code>, <code>title_callback</code> will not be called.</p>\n<pre><code>title_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>title_arguments</code> &#8211; An array of query variables whose values will be passed<br />\nas arguments to <code>title_callback</code>. Defaults to the value of <code>title</code>. If an argument<br />\nis not a registered query variable, it will be passed as-is.</p>\n</li>\n<li>\n<p><code>page_callback</code> (required) &#8211; A callback to use for dynamically generating the<br />\ncontents of the page. The callback should either echo or return the contents of<br />\nthe page (if both, the returned value will be appended to the echoed value). If<br />\n    FALSE is returned, nothing will be output, and control of the page contents will<br />\nbe handed back to WordPress. The callback will be called during the <code>parse_request</code><br />\nphase of WordPress&#8217;s page load. If <code>access_callback</code> returns <code>FALSE</code>, <code>page_callback</code><br />\nwill not be called.</p>\n<pre><code>page_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>page_arguments</code> &#8211; An array of query variables whose values will be passed as<br />\narguments to <code>page_callback</code>. If an argument is not a registered query variable,<br />\nit will be passed as-is.</p>\n</li>\n<li>\n<p><code>access_callback</code> &#8211; A callback to determine if the user has permission to access<br />\nthis page. If <code>access_arguments</code> is provided, default is <code>current_user_can</code>, otherwise<br />\ndefault is <code>TRUE</code>. If the callback returns <code>FALSE</code>, anonymous users are redirected to<br />\nthe login page, authenticated users get a 403 error.</p>\n<pre><code>access_callback can be either a single callback function or an array specifying\n</code></pre>\n<p>callback functions for specific HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.).<br />\nIf the latter, the <code>default</code> key will be used if no other keys match the current<br />\nrequest method.</p>\n</li>\n<li>\n<p><code>access_arguments</code> &#8211; An array of query variables whose values will be passed<br />\nas arguments to <code>access_callback</code>. If an argument is not a registered query variable,<br />\nit will be passed as-is.</p>\n</li>\n<li>\n<p><code>template</code> &#8211; An array of templates that can be used to display the page. If a path<br />\nis absolute, it will be used as-is; relative paths allow for overrides by the theme.<br />\nThe string <code>$id</code> will be replaced with the ID of the route. If no template is found,<br />\nfallback templates are (in this order): <code>route-$id.php</code>, <code>route.php</code>, <code>page-$id.php</code>,<br />\n    page.php, <code>index.php</code>. If FALSE is given instead of an array, the page contents will<br />\nbe printed before calling <code>exit()</code> (you can also accomplish this by printing your output<br />\nand exiting directly from your callback function).</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Example:<br />\n    $router-&gt;add_route(&#8216;wp-router-sample&#8217;, array(<br />\n        &#8216;path&#8217; =&gt; &#8216;^wp_router/(.*?)$&#8217;,<br />\n        &#8216;query_vars&#8217; =&gt; array(<br />\n            &#8216;sample_argument&#8217; =&gt; 1,<br />\n        ),<br />\n        &#8216;page_callback&#8217; =&gt; array(get_class(), &#8216;sample_callback&#8217;),<br />\n        &#8216;page_arguments&#8217; =&gt; array(&#8216;sample_argument&#8217;),<br />\n        &#8216;access_callback&#8217; =&gt; TRUE,<br />\n        &#8216;title&#8217; =&gt; &#8216;WP Router Sample Page&#8217;,<br />\n        &#8216;template&#8217; =&gt; array(&#8216;sample-page.php&#8217;, dirname(<strong>FILE</strong>).DIRECTORY_SEPARATOR.&#8217;sample-page.php&#8217;)<br />\n    ));</p>\n<p>In this example, the path <code>http://example.com/wp_router/my_sample_path/</code> will call<br />\nthe function <code>sample_callback</code> in the calling class. The value of the <code>sample_argument</code><br />\nquery variable, in this case &#8220;my_sample_path&#8221;, will be provided as the first and only<br />\nargument to the callback function. If the file <code>sample-page.php</code> is found in the theme,<br />\nit will be used as the template, otherwise <code>sample-page.php</code> in your plugin directory will<br />\nbe used (if that&#8217;s not found either, fall back to <code>route-wp-router-sample.php</code>, etc.).</p>\n<h4>Editing Routes</h4>\n<ul>\n<li>You can hook into the <code>wp_router_alter_routes</code> action to modify routes created by other plugins. The callback should take one argument, a <code>WP_Router</code> object.</li>\n</ul>\n<h4>Public API Functions</h4>\n<p>Creating or changing routes should always occur in the context of the <code>wp_router_generate_routes</code> or <code>wp_router_alter_routes</code> actions, using the <code>WP_Router</code> object supplied to your callback function.</p>\n<ul>\n<li><code>WP_Router::edit_route( string $id, array $changes )</code> &#8211; update each<br />\nproperty given in <code>$changes</code> for the route with the given ID. Any properties<br />\nnot given in <code>$changes</code> will be left unaltered.</li>\n<li><code>WP_Router::remove_route( string $id )</code> &#8211; delete the route with the given ID</li>\n<li><code>WP_Router::get_route( string $id )</code> &#8211; get the <code>WP_Route</code> object for the given ID</li>\n<li><code>WP_Router::get_url( string $id, array $arguments )</code> &#8211; get the URL to reach the route with the given ID, with the given query variables and their values</li>\n<li><code>WP_Route::get( string $property )</code> &#8211; get the value of the specified property for<br />\nthe <code>WP_Route</code> instance</li>\n</ul>\n",
    "download_link": "https://downloads.wordpress.org/plugin/wp-router.zip",
    "upgrade_notice": [],
    "screenshots": [],
    "tags": {
        "callback-functions": "callback functions",
        "url-mapping": "URL mapping"
    },
    "stable_tag": "trunk",
    "versions": [],
    "business_model": false,
    "repository_url": "",
    "commercial_support_url": "",
    "donate_link": "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=A69NZPKWGB6H2",
    "banners": [],
    "icons": {
        "default": "https://s.w.org/plugins/geopattern-icon/wp-router.svg"
    },
    "blocks": [],
    "block_assets": [],
    "author_block_count": 0,
    "author_block_rating": 74,
    "blueprints": [],
    "preview_link": "",
    "language_packs": []
}