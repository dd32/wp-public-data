{
    "name": "Jinx Fast-Cache",
    "slug": "jinx-fast-cache",
    "version": "0.8.0",
    "author": "<a href=\"http://jinx-digital.com\">Jinx Digital </a>",
    "author_profile": "https://profiles.wordpress.org/lugat/",
    "contributors": {
        "lugat": {
            "profile": "https://profiles.wordpress.org/lugat/",
            "avatar": "https://secure.gravatar.com/avatar/58df860eb992823fb466f513a5f6b105?s=96&d=monsterid&r=g",
            "display_name": "Lukas Rydygel"
        }
    },
    "requires": "5.0",
    "tested": "6.4.5",
    "requires_php": "8.0",
    "requires_plugins": [],
    "compatibility": [],
    "rating": 0,
    "ratings": {
        "5": 0,
        "4": 0,
        "3": 0,
        "2": 0,
        "1": 0
    },
    "num_ratings": 0,
    "support_url": "https://wordpress.org/support/plugin/jinx-fast-cache/",
    "support_threads": 0,
    "support_threads_resolved": 0,
    "active_installs": 0,
    "downloaded": 790,
    "last_updated": "2023-12-20 2:10pm GMT",
    "added": "2022-02-10",
    "homepage": "https://wordpress.org/plugins/jixn-fast-cache/",
    "sections": {
        "description": "<p>Jinx Fast-Cache provides a very simple but efficient way of full page caching to WordPress.<br />\nIt will generate static HTML files which will be called using your servers rewrite rules.<br />\nThis feature will bypass the whole PHP process and render only a simple HTML file without the whole overhead.</p>\n<h3>Usage</h3>\n<p>After activating the plugin, it will modify your .htaccess file. If this is not possible, make sure to enter the rules by yourself:</p>\n<pre><code># BEGIN Jinx Fast-Cache\nRewriteEngine On\nRewriteBase /\nRewriteCond %{DOCUMENT_ROOT}/wp-content/jinx-fast-cache/%{HTTP_HOST}/%{REQUEST_URI}/%{QUERY_STRING}/index.html -s\nRewriteCond %{REQUEST_METHOD} GET\nRewriteRule .* /wp-content/jinx-fast-cache/%{HTTP_HOST}/%{REQUEST_URI}/%{QUERY_STRING}/index.html [L]\n# END Jinx Fast-Cache\n</code></pre>\n<p>When using nginx, make sure to add the following rules:</p>\n<pre><code>set $cache_path false;\nif ($request_method = GET) {\n  set $cache_path /wp-content/jinx-fast-cache/$host/$uri/$args/index.html;\n}\nlocation / {\n  try_files $cache_path $uri $uri/ /index.php?$query_string;\n}\n</code></pre>\n<p>You may flush, warm or refresh (flush &amp; warm) single or multiple URLs using the buttons in the admin bar.</p>\n<p>By default all posts will be automatically warmed after they have been saved and flushed after they have been deleted or put on draft.</p>\n<p>The warm process will create a queue, which will be handled in a scheduled task (cron). When warming up a single post, it will skip the queue.</p>\n<p>The plugin will automatically flush and warm the cache after an update has been completed.</p>\n<h3>Developers</h3>\n<h3>Filters</h3>\n<p>Jinx Fast-Cache is made for developers. So far no admin panel is available, but you may modify a lot of it&#8217;s behaviors using filters.</p>\n<ul>\n<li><strong>jinx_fast_cache_active</strong>: Control if an URL should be cached (default true) or not.</li>\n<li><strong>jinx_fast_cache_post_types</strong>: Control the post types which should be cached. By default all post types which are &#8220;publicly_queryable&#8221; and &#8220;page&#8221; will be cached.</li>\n<li><strong>jinx_fast_cache_posts</strong>: Filter the posts which should be cached.</li>\n<li><strong>jinx_fast_cache_taxonomies</strong>: Control the taxonomies which should be cached. By default all taxonomies which are &#8220;publicly_queryable&#8221; will be cached.</li>\n<li><strong>jinx_fast_cache_terms</strong>: Filter the terms which should be cached.</li>\n<li><strong>jinx_fast_cache_output</strong>: Use this to modify the HTML content written to your cache file.</li>\n<li><strong>jinx_fast_cache_minify</strong>: Control if the output should be minified (default true) or not.</li>\n<li><strong>jinx_fast_cache_flush</strong>: Control which URLs should be flushed. This may be used to flush related URLs eg. your front page.</li>\n<li><strong>jinx_fast_cache_warm</strong>: Control which URLs should be warmed. This may be used to warm related URLs eg. your front page.</li>\n<li><strong>jinx_fast_cache_queue_interval</strong>: Change the interval of the queues cron task (default 60) to warm URLs.</li>\n<li><strong>jinx_fast_cache_queue_size</strong>: Change the number of URLs which should be handled durring a cron task (default 10). When setting it to &lt;= 0, all URLs will be handled. This may cause a huge load when you have a lot of URLs.</li>\n<li><strong>jinx_fast_cache_gc_interval</strong>: Change the interval of the GCs cron task (default 60) to flush invalid URLs.</li>\n<li><strong>jinx_fast_cache_ignore_404</strong>: Control if 404 errors should be cached (default false) or not. Not that a lot of 404 errors will also create a lot of cache files on your server.</li>\n<li><strong>jinx_fast_cache_query_params</strong>: Control if and which query params will be accepted. You may pass &#8216;__return_empty_array&#8217; to allow no query params at all.</li>\n<li><strong>jinx_fast_cache_refresh_on_upgrade</strong>: Control if the cache should be refreshed on upgrade (default true).</li>\n<li><strong>jinx_fast_cache_duration</strong>: Change the caches duration (default null). The cache of URLs without a duration will always be valid. You may use a numeric value eg. 3600 or something like &#8217;12 hours&#8217; or &#8216;1 week&#8217; etc.</li>\n</ul>\n<h3>Injections</h3>\n<p>Jinx Fast-Cache also provides the feature to inject dynamic content into your pages. If you eg. want to print the users name on the page, you may inject it via ajax.<br />\nYou may also use a placeholder to let your users know, that the content will be loading eg. &#8220;loading &#8230;&#8221;.</p>\n<p>Inject a template:</p>\n<pre><code>do_action('jinx_fast_cache_inject_template', 'user');\ndo_action('jinx_fast_cache_inject_template', 'user', 'loading ...');\n</code></pre>\n<p>This has the same effect as:</p>\n<pre><code>do_action('jinx_fast_cache_inject', 'get_template_part', ['user']);\ndo_action('jinx_fast_cache_inject', 'get_template_part', ['user'], 'loading ...');\n</code></pre>\n<p>You may call every public function of PHP, your theme or any plugin:</p>\n<pre><code>do_action('jinx_fast_cache_inject', 'date', ['Y']);\ndo_action('jinx_fast_cache_inject', 'my_function', ['param1', 'param2']);\ndo_action('jinx_fast_cache_inject', 'namespace\\MyClass::myMethod', ['param1', 'param2']);\ndo_action('jinx_fast_cache_inject', ['namespace\\MyClass', 'myMethod'], ['param1', 'param2']);\n</code></pre>\n<p>The first parameter is the function call, the second parameter is an array or arguments passed to this function and the third parameter is the placeholder.</p>\n<p>Inside the editor, you may also use shortcodes to inject content.</p>\n<pre><code>[jinx_fast_cache_inject]My dynamic content or other shortcodes can be used here[/jinx_fast_cache_inject]\n[jinx_fast_cache_inject placeholder=\"loading...\"]My dynamic content or other shortcodes can be used here[/jinx_fast_cache_inject]\n</code></pre>\n<p>Every shortcode or block between &#8220;jinx_fast_cache_inject&#8221; will be parsed and injected via ajax. Note that this may cause problems when working with JS events.</p>\n<h3>Injection Callbacks</h3>\n<p>You may trigger custom JS after dynamic content has been injected.</p>\n<p>Using jQuery:</p>\n<pre><code>$('.element').on('jinx-fast-cache-inject', function(e) {\n  // so smth. with e.target or this\n});\n</code></pre>\n<p>Using VanillaJS:</p>\n<pre><code>element.addEventListener('jinx-fast-cache-inject' (e) =&gt; {\n  // so smth. with e.target\n}, false);&lt;h3&gt;Tags&lt;/h3&gt;\n</code></pre>\n<p>Even there are some filters to build a relation between URLs, tags are an easier way to do this.<br />\nYou may connect multiple URLs with tags, so if one URL gets flushed, it will also flush URLs with the same tag.</p>\n<p>Tags can be used inside the editor by using the shortcode:</p>\n<pre><code>[jinx_fast_cache tags=\"foo,bar\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['tags' =&gt; 'foo,bar']);\ndo_action('jinx_fast_cache', ['tags' =&gt; ['foo', 'bar']]);\n</code></pre>\n<p>A usecase for tags might be to connect single posts with your page for posts. So if a single post will be flushed, the page for posts and all other posts will also be flushed.</p>\n<p>You may also add multiple tags by calling the shortcode or action multiple times. This will work very well when using blocks or other shortcodes.</p>\n<h3>Cache duration</h3>\n<p>As you have seen already, you may set a cache duration globally by using the filter &#8216;jinx_fast_cache_duration&#8217;.<br />\nHowever, if there is a specific URL eg. the front page, you may want to change the duration.</p>\n<p>You may use a shortcode like this:</p>\n<pre><code>[jinx_fast_cache duration=\"3600\"]\n[jinx_fast_cache duration=\"12 hours\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['duration' =&gt; 3600]);&lt;h3&gt;Hits&lt;/h3&gt;\n</code></pre>\n<p>Be aware that you can set tags and the cache duration in just one call.</p>\n<pre><code>[jinx_fast_cache duration=\"3600\" tags=\"foo,bar\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['duration' =&gt; 3600, 'tags' =&gt; 'foo,bar']);\ndo_action('jinx_fast_cache', ['duration' =&gt; 3600, 'tags' =&gt; ['foo', 'bar']]);\n</code></pre>\n<p>Note that tags will accept a string or an array.</p>\n<h3>Roadmap</h3>\n<ul>\n<li>[x] Release the plugin</li>\n<li>[x] Add HTML minification for output</li>\n<li>[x] Allow injection of dynamic rendered templates using ajax requests</li>\n<li>[x] Add taxonomies</li>\n<li>[x] Provide scheduled tasks</li>\n<li>[x] Add admin columns for cache status</li>\n<li>[x] Provide exclude option for posts and terms in backend</li>\n<li>[x] Add multisite support</li>\n<li>[x] Flush and warm after update complete</li>\n<li>[x] Add possibility to ignore 404</li>\n<li>[x] Allow query params to be excluded or totally ignored</li>\n<li>[x] Provide cache duration</li>\n<li>[ ] Provide admin panel to change options</li>\n<li>[x] Add tags to flush related pages</li>\n<li>[x] Add shortcode for injects</li>\n<li>[x] Add JS events for injects</li>\n</ul>\n",
        "installation": "<ol>\n<li>Unzip the downloaded package</li>\n<li>Upload <code>jinx-fast-cache</code> to the <code>/wp-content/plugins/</code> directory</li>\n<li>Activate the plugin through the &#8216;Plugins&#8217; menu in WordPress</li>\n<li>Optional: You may need to modify the rewrite rules</li>\n</ol>\n"
    },
    "short_description": "Jinx Fast-Cache is a blazing fast full page cache for WordPress, written for developers. The goal was to create a caching plugin without the overhead  &hellip;",
    "description": "<p>Jinx Fast-Cache provides a very simple but efficient way of full page caching to WordPress.<br />\nIt will generate static HTML files which will be called using your servers rewrite rules.<br />\nThis feature will bypass the whole PHP process and render only a simple HTML file without the whole overhead.</p>\n<h3>Usage</h3>\n<p>After activating the plugin, it will modify your .htaccess file. If this is not possible, make sure to enter the rules by yourself:</p>\n<pre><code># BEGIN Jinx Fast-Cache\nRewriteEngine On\nRewriteBase /\nRewriteCond %{DOCUMENT_ROOT}/wp-content/jinx-fast-cache/%{HTTP_HOST}/%{REQUEST_URI}/%{QUERY_STRING}/index.html -s\nRewriteCond %{REQUEST_METHOD} GET\nRewriteRule .* /wp-content/jinx-fast-cache/%{HTTP_HOST}/%{REQUEST_URI}/%{QUERY_STRING}/index.html [L]\n# END Jinx Fast-Cache\n</code></pre>\n<p>When using nginx, make sure to add the following rules:</p>\n<pre><code>set $cache_path false;\nif ($request_method = GET) {\n  set $cache_path /wp-content/jinx-fast-cache/$host/$uri/$args/index.html;\n}\nlocation / {\n  try_files $cache_path $uri $uri/ /index.php?$query_string;\n}\n</code></pre>\n<p>You may flush, warm or refresh (flush &amp; warm) single or multiple URLs using the buttons in the admin bar.</p>\n<p>By default all posts will be automatically warmed after they have been saved and flushed after they have been deleted or put on draft.</p>\n<p>The warm process will create a queue, which will be handled in a scheduled task (cron). When warming up a single post, it will skip the queue.</p>\n<p>The plugin will automatically flush and warm the cache after an update has been completed.</p>\n<h3>Developers</h3>\n<h3>Filters</h3>\n<p>Jinx Fast-Cache is made for developers. So far no admin panel is available, but you may modify a lot of it&#8217;s behaviors using filters.</p>\n<ul>\n<li><strong>jinx_fast_cache_active</strong>: Control if an URL should be cached (default true) or not.</li>\n<li><strong>jinx_fast_cache_post_types</strong>: Control the post types which should be cached. By default all post types which are &#8220;publicly_queryable&#8221; and &#8220;page&#8221; will be cached.</li>\n<li><strong>jinx_fast_cache_posts</strong>: Filter the posts which should be cached.</li>\n<li><strong>jinx_fast_cache_taxonomies</strong>: Control the taxonomies which should be cached. By default all taxonomies which are &#8220;publicly_queryable&#8221; will be cached.</li>\n<li><strong>jinx_fast_cache_terms</strong>: Filter the terms which should be cached.</li>\n<li><strong>jinx_fast_cache_output</strong>: Use this to modify the HTML content written to your cache file.</li>\n<li><strong>jinx_fast_cache_minify</strong>: Control if the output should be minified (default true) or not.</li>\n<li><strong>jinx_fast_cache_flush</strong>: Control which URLs should be flushed. This may be used to flush related URLs eg. your front page.</li>\n<li><strong>jinx_fast_cache_warm</strong>: Control which URLs should be warmed. This may be used to warm related URLs eg. your front page.</li>\n<li><strong>jinx_fast_cache_queue_interval</strong>: Change the interval of the queues cron task (default 60) to warm URLs.</li>\n<li><strong>jinx_fast_cache_queue_size</strong>: Change the number of URLs which should be handled durring a cron task (default 10). When setting it to &lt;= 0, all URLs will be handled. This may cause a huge load when you have a lot of URLs.</li>\n<li><strong>jinx_fast_cache_gc_interval</strong>: Change the interval of the GCs cron task (default 60) to flush invalid URLs.</li>\n<li><strong>jinx_fast_cache_ignore_404</strong>: Control if 404 errors should be cached (default false) or not. Not that a lot of 404 errors will also create a lot of cache files on your server.</li>\n<li><strong>jinx_fast_cache_query_params</strong>: Control if and which query params will be accepted. You may pass &#8216;__return_empty_array&#8217; to allow no query params at all.</li>\n<li><strong>jinx_fast_cache_refresh_on_upgrade</strong>: Control if the cache should be refreshed on upgrade (default true).</li>\n<li><strong>jinx_fast_cache_duration</strong>: Change the caches duration (default null). The cache of URLs without a duration will always be valid. You may use a numeric value eg. 3600 or something like &#8217;12 hours&#8217; or &#8216;1 week&#8217; etc.</li>\n</ul>\n<h3>Injections</h3>\n<p>Jinx Fast-Cache also provides the feature to inject dynamic content into your pages. If you eg. want to print the users name on the page, you may inject it via ajax.<br />\nYou may also use a placeholder to let your users know, that the content will be loading eg. &#8220;loading &#8230;&#8221;.</p>\n<p>Inject a template:</p>\n<pre><code>do_action('jinx_fast_cache_inject_template', 'user');\ndo_action('jinx_fast_cache_inject_template', 'user', 'loading ...');\n</code></pre>\n<p>This has the same effect as:</p>\n<pre><code>do_action('jinx_fast_cache_inject', 'get_template_part', ['user']);\ndo_action('jinx_fast_cache_inject', 'get_template_part', ['user'], 'loading ...');\n</code></pre>\n<p>You may call every public function of PHP, your theme or any plugin:</p>\n<pre><code>do_action('jinx_fast_cache_inject', 'date', ['Y']);\ndo_action('jinx_fast_cache_inject', 'my_function', ['param1', 'param2']);\ndo_action('jinx_fast_cache_inject', 'namespace\\MyClass::myMethod', ['param1', 'param2']);\ndo_action('jinx_fast_cache_inject', ['namespace\\MyClass', 'myMethod'], ['param1', 'param2']);\n</code></pre>\n<p>The first parameter is the function call, the second parameter is an array or arguments passed to this function and the third parameter is the placeholder.</p>\n<p>Inside the editor, you may also use shortcodes to inject content.</p>\n<pre><code>[jinx_fast_cache_inject]My dynamic content or other shortcodes can be used here[/jinx_fast_cache_inject]\n[jinx_fast_cache_inject placeholder=\"loading...\"]My dynamic content or other shortcodes can be used here[/jinx_fast_cache_inject]\n</code></pre>\n<p>Every shortcode or block between &#8220;jinx_fast_cache_inject&#8221; will be parsed and injected via ajax. Note that this may cause problems when working with JS events.</p>\n<h3>Injection Callbacks</h3>\n<p>You may trigger custom JS after dynamic content has been injected.</p>\n<p>Using jQuery:</p>\n<pre><code>$('.element').on('jinx-fast-cache-inject', function(e) {\n  // so smth. with e.target or this\n});\n</code></pre>\n<p>Using VanillaJS:</p>\n<pre><code>element.addEventListener('jinx-fast-cache-inject' (e) =&gt; {\n  // so smth. with e.target\n}, false);&lt;h3&gt;Tags&lt;/h3&gt;\n</code></pre>\n<p>Even there are some filters to build a relation between URLs, tags are an easier way to do this.<br />\nYou may connect multiple URLs with tags, so if one URL gets flushed, it will also flush URLs with the same tag.</p>\n<p>Tags can be used inside the editor by using the shortcode:</p>\n<pre><code>[jinx_fast_cache tags=\"foo,bar\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['tags' =&gt; 'foo,bar']);\ndo_action('jinx_fast_cache', ['tags' =&gt; ['foo', 'bar']]);\n</code></pre>\n<p>A usecase for tags might be to connect single posts with your page for posts. So if a single post will be flushed, the page for posts and all other posts will also be flushed.</p>\n<p>You may also add multiple tags by calling the shortcode or action multiple times. This will work very well when using blocks or other shortcodes.</p>\n<h3>Cache duration</h3>\n<p>As you have seen already, you may set a cache duration globally by using the filter &#8216;jinx_fast_cache_duration&#8217;.<br />\nHowever, if there is a specific URL eg. the front page, you may want to change the duration.</p>\n<p>You may use a shortcode like this:</p>\n<pre><code>[jinx_fast_cache duration=\"3600\"]\n[jinx_fast_cache duration=\"12 hours\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['duration' =&gt; 3600]);&lt;h3&gt;Hits&lt;/h3&gt;\n</code></pre>\n<p>Be aware that you can set tags and the cache duration in just one call.</p>\n<pre><code>[jinx_fast_cache duration=\"3600\" tags=\"foo,bar\"]\n</code></pre>\n<p>Or you can use it inside your templates by calling the action:</p>\n<pre><code>do_action('jinx_fast_cache', ['duration' =&gt; 3600, 'tags' =&gt; 'foo,bar']);\ndo_action('jinx_fast_cache', ['duration' =&gt; 3600, 'tags' =&gt; ['foo', 'bar']]);\n</code></pre>\n<p>Note that tags will accept a string or an array.</p>\n<h3>Roadmap</h3>\n<ul>\n<li>[x] Release the plugin</li>\n<li>[x] Add HTML minification for output</li>\n<li>[x] Allow injection of dynamic rendered templates using ajax requests</li>\n<li>[x] Add taxonomies</li>\n<li>[x] Provide scheduled tasks</li>\n<li>[x] Add admin columns for cache status</li>\n<li>[x] Provide exclude option for posts and terms in backend</li>\n<li>[x] Add multisite support</li>\n<li>[x] Flush and warm after update complete</li>\n<li>[x] Add possibility to ignore 404</li>\n<li>[x] Allow query params to be excluded or totally ignored</li>\n<li>[x] Provide cache duration</li>\n<li>[ ] Provide admin panel to change options</li>\n<li>[x] Add tags to flush related pages</li>\n<li>[x] Add shortcode for injects</li>\n<li>[x] Add JS events for injects</li>\n</ul>\n",
    "download_link": "https://downloads.wordpress.org/plugin/jinx-fast-cache.zip",
    "upgrade_notice": {
        "": "<p>When updating, by default the plugin will flush the cache. Anyway, it may be a good idea to deactivate and activate the plugin again, if there are any problems after an upgrade.</p>"
    },
    "screenshots": [],
    "tags": {
        "cache": "cache",
        "files": "files",
        "fullpage": "fullpage",
        "html": "html",
        "pagecache": "pagecache"
    },
    "stable_tag": "trunk",
    "versions": [],
    "business_model": false,
    "repository_url": "",
    "commercial_support_url": "",
    "donate_link": "",
    "banners": {
        "low": "https://ps.w.org/jinx-fast-cache/assets/banner-772x250.jpg?rev=2676361",
        "high": false
    },
    "icons": {
        "1x": "https://ps.w.org/jinx-fast-cache/assets/icon-128x128.png?rev=2676361",
        "2x": "https://ps.w.org/jinx-fast-cache/assets/icon-256x256.png?rev=2676361"
    },
    "blocks": [],
    "block_assets": [],
    "author_block_count": 0,
    "author_block_rating": 0,
    "blueprints": [],
    "preview_link": "",
    "language_packs": []
}